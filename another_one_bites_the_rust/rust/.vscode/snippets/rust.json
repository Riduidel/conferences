{
  "Read command line args": {
    "prefix": "0_1_read_command_line",
    "body": [
      "let args: Vec<_> = env::args().collect();"
    ]
  },
  "Read only the real argument": {
    "prefix": "0_2_parse_command_line",
    "body": [
      "let first = env::args().nth(1).expect(\"please supply an argument\");",
      "let n: i32 = first.parse().expect(\"not an integer!\");"
    ]
  },
  "Install structopt": {
    "prefix": "0_3_structopt_declare",
    "body": [
      "#[macro_use]",
      "extern crate structopt;",
      "\nuse structopt::StructOpt;",
      "\n#[derive(Debug, StructOpt)]",
      "#[structopt()]",
      "struct Options {",
      "    number:i32",
      "}\n"
    ]
  },
  "Use structopt": {
    "prefix": "0_4_structopt_use",
    "body": [
      "let opt = Options::from_args();"
    ]
  },
  "FizzBuzz with an if": {
    "prefix": "1_1_fizzbuzz_if",
    "body": [
      "fn fizzbuzz(i:i32)->String {",
      "   let divisible_by_three = i % 3 == 0;",
      "   let divisible_by_five = i % 5 == 0;",
      "   ",
      "   if divisible_by_three && divisible_by_five {",
      "       return \"FizzBuzz\".to_owned();",
      "   } else if divisible_by_three {",
      "       return \"Fizz\".to_owned();",
      "   } else if divisible_by_five {",
      "       return \"Buzz\".to_owned();",
      "   } else {",
      "       return format!(\"{}\", i);",
      "   }",
      "}"
    ]
  },
  "FizzBuzz tests": {
    "prefix": "1_0_fizzbuzz_test",
    "body": [
      "#[cfg(test)]",
      "mod tests {",
      "    // Note this useful idiom: importing names from outer (for mod tests) scope.",
      "    use super::*;",
      "",
      "    #[test]",
      "    fn test_2() {",
      "        assert_eq!(fizzbuzz(2), \"2\");",
      "    }",
      "}"
    ]
  },
  "FizzBuzz enum": {
    "prefix": "1_2_fizzbuzz_enum",
    "body": [
      "#[derive(Debug)]",
      "enum FizzBuzz {",
      "    Fizz,",
      "    Buzz,",
      "    FizzBuzz,",
      "    Other(i32),",
      "}"
    ]
  },
  "FizzBuzz from": {
    "prefix": "1_3_fizzbuzz_from",
    "body": [
      "impl From<i32> for FizzBuzz {",
      "  fn from(item: i32) -> Self {",
      "      match (item % 3 == 0, item % 5 == 0) {",
      "          (false, false) => FizzBuzz::Other(item),",
      "          (true, false) => FizzBuzz::Fizz,",
      "          (false, true) => FizzBuzz::Buzz,",
      "          (true, true) => FizzBuzz::FizzBuzz,",
      "      }",
      "  }",
      "}"
    ]
  },
  "FizzBuzz to_string": {
    "prefix": "1_4_fizzbuzz_to_string",
    "body": [
      "impl ToString for FizzBuzz {",
      "  fn to_string(&self) -> String {",
      "      match self {",
      "          FizzBuzz::Other(number) => return format!(\"{:?}\", number),",
      "          _ => return format!(\"{:?}\", self)",
      "      }",
      "  }",
      "}"
      ]
  },
  "FizzBuzz multi_parameters": {
    "prefix": "1_7_fizzbuzz_multi_param_map",
    "body": [
      "let mut result = String::new();",
      "for i in opt.numbers {",
      "    result.push_str(\" \");",
      "    result.push_str(&fizzbuzz(i));",
      "}"
      ]
  },
  "FizzBuzz multi_parameters old school": {
    "prefix": "1_6_fizzbuzz_multi_param_loop",
    "body": [
      "println!(\"{}\", opt.numbers.iter()",
      "   .map(|&i| fizzbuzz(i))",
      "   .fold(\" \".to_owned(), |acc, value| format!(\"{} {}\", acc, value)));"
    ]
  },
  "FizzBuzz Warp": {
    "prefix": "2_1_warp_hello",
    "body": [
      "#[macro_use]",
      "extern crate warp;",
      "",
      "use warp::Filter;",
      "",
      "fn main() {",
      "    let hello = path!(\"hello\" / String)",
      "        .map(|name| format!(\"Hello, {}!\", name));",
      "",
      "    warp::serve(hello)",
      "        .run(([127, 0, 0, 1], 3030));",
      "}"
    ]
  }
}